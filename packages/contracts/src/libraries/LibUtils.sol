// SPDX-License-Identifier: MIT
pragma solidity >=0.8.21;

library LibUtils {
  /**
   * @notice simple rng calculation
   * @dev     complexity needs to be increased in prod
   * @param   r1  first source of randomness
   * @param   r2  second source of randomness
   * @return  r  random value
   */
  function random(uint256 r1, uint256 r2) internal view returns (uint256 r) {
    return uint256(keccak256(abi.encodePacked(r1, r2, block.prevrandao, blockhash(block.number - 1))));
  }

  /**
   * @dev Returns the largest of two numbers.
   */
  function max(int32 a, int32 b) internal pure returns (int32) {
    return a > b ? a : b;
  }

  /**
   * @dev Returns the smallest of two numbers.
   */
  function min(int32 a, int32 b) internal pure returns (int32) {
    return a < b ? a : b;
  }

  /**
   * @dev Clamps return value to _upperBound
   * @param _value value to be clamped
   * @param _upperBound upper bound
   * @return clamped value
   */
  function clamp(uint32 _value, uint32 _upperBound) internal pure returns (uint32) {
    if (_value > _upperBound) {
      return _upperBound;
    } else {
      return _value;
    }
  }

  /**
   * @dev Returns the absolute value
   */
  function abs(int32 x) internal pure returns (int32) {
    return x >= 0 ? x : -x;
  }

  /**
   * @dev Returns the absolute difference
   */
  function absDif(int32 a, int32 b) internal pure returns (uint32) {
    return uint32(a > b ? a - b : b - a);
  }

  /**
   * @dev Conversion from address to bytes32
   */
  function addressToEntityKey(address _address) internal pure returns (bytes32 key) {
    return bytes32(uint256(uint160(_address)));
  }

  /**
   * @dev Generates a pseudo-random key based on the current block number, the message sender, and the remaining gas.
   *
   * This function uses the `keccak256` hashing function to produce a unique key. It's important to note that while
   * the generated key might seem random, it can be deterministically recreated with the same block, sender, and gas conditions.
   * It is not suitable for strong cryptographic purposes.
   *
   * @return key A pseudo-randomly generated bytes32 key.
   */
  function getRandomKey() internal view returns (bytes32 key) {
    return keccak256(abi.encode(block.number, msg.sender, gasleft()));
  }

  /**
   * @dev Checks if a given `_id` exists within the provided `_nodes` array.
   *
   * @param _nodes The list of node IDs of type bytes32.
   * @param _id The ID to check for its existence in the `_nodes` list.
   * @return true if `_id` exists in `_nodes`, false otherwise.
   */
  function isIdPresent(bytes32[] memory _nodes, bytes32 _id) internal pure returns (bool) {
    for (uint i = 0; i < _nodes.length; i++) {
      if (_nodes[i] == _id) {
        return true;
      }
    }
    return false;
  }
}
